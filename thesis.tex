\documentclass[12pt,oneside]{fithesis2}
\usepackage[english]{babel}       % Multilingual support
\usepackage[utf8]{inputenc}       % UTF-8 encoding
\usepackage[T1]{fontenc}          % T1 font encoding
\usepackage[                      % A sans serif font that blends well with Palatino
  scaled=0.86
]{berasans}
\usepackage[                      % A tt font if you do not like LM's tt
  scaled=1.03
]{inconsolata}
\usepackage{blindtext}
\usepackage{url}
\usepackage[                      % Clickable links
  plainpages = false,               % We have multiple page numberings
  pdfpagelabels                     % Generate pdf page labels
]{hyperref}            % Lorem ipsum generator
\usepackage{listings}
\lstset{language=C, frame=lrtb, captionpos=b, breaklines=true, literate={\\\-}{}{0\discretionary{-}{}{}}}

\thesislang{en}                   % The language of the thesis
\thesistitle{Extend WildFly Application Server logging capabilities}       % The title of the thesis
\thesissubtitle{Diploma Thesis}  % The type of the thesis
\thesisstudent{Bc. Radek Koubsk√Ω}          % Your name
\thesiswoman{true}                % Your gender
\thesisfaculty{fi}                % Your faculty
\thesisyear{\the\year}     % The academic term of your thesis defense
\thesisadvisor{RNDr. Adam Rambousek, Ph.D.}   % Your advisor

\begin{document}
  \FrontMatter                    % The front matter
    \ThesisTitlePage                % The title page
    \begin{ThesisDeclaration}       % The declaration
      \DeclarationText
      \AdvisorName
    \end{ThesisDeclaration}
    \begin{ThesisThanks}            % The acknowledgements (optional)
      I would like to thank my supervisor\,\dots
    \end{ThesisThanks}
    \begin{ThesisAbstract}          % The abstract
      The aim of the bachelor work is to provide\,\dots
    \end{ThesisAbstract}
    \begin{ThesisKeyWords}          % The keywords
      keyword1, keyword2\,\dots
    \end{ThesisKeyWords}
    \tableofcontents                % The table of contents
%   \listoftables                   % The list of tables (optional)
%   \listoffigures                  % The list of figures (optional)
  
  \MainMatter                     % The main matter
    \chapter{Introduction}          % Chapters
    \Blindtext
\chapter{Byteman}
This chapter aims to introduce \textit{Byteman}, a bytecode manipulation tool, and its usage in java applications. Fundamental principles, functions and structure of Byteman will be described.
At the end of the chapter, an example of simple java application will be provided in order to understand bytecode injection which Byteman uses. More detailed documentation, tutorials and guidelines 
which cover almost every aspect of Byteman can be found in different versions at official website \url{http://byteman.jboss.org/}. Primary source for this thesis is Byteman documentation 3.0.0 \cite{byteman_doc}.

\section{Introduction to Byteman}
Byteman is a bytecode manipulation tool which uses a bytecode injection\footnote{Bytecode injection (or bytecode instrumentation) is a process of modifying the actual bytecode of a class} in order to change a java application either as it is being loaded by \textit{Java virtual machine} or while the application is running \cite[Introduction to Byteman]{byteman_doc}.

Because of the bytecode injection, there is no need to change the original source code nor to recompile, redeploy the application itself. As it was mentioned, it is possible to add, replace or remove injected code at runtime while the application continues in execution. Byteman also provides a way to inject code into the Java language by modifying classes such as \textit{java.lang.Thread} and other classes from \textit{java.lang} package. Byteman uses simple scripting language called \textit{Event Condition Action)} (\ref{subsec:eca_sec}) rules to determine how the original Java code should be transformed according to event and condition.

The original purpose of Byteman was to provide a mechanism for automation tests used in multi-threaded and multi-JVM Java applications using a technique called fault injection. Byteman can be used to inject faults which cause an application to invoke unusual or unexpected methods which are required for certain test scenarios. There are four areas supported by Byteman in automation testing \cite[Introduction to Byteman]{byteman_doc}:

\begin{itemize}
   \item tracing execution of specific code paths and displaying application or JVM state
   \item subverting normal execution by changing state, making unscheduled method calls or forcing an unexpected return or throw
   \item orchestrating the timing of activities performed by independent application threads
   \item monitoring and gathering statistics summarising application and JVM operation
\end{itemize}

However, the concept of bytecode injection involves Byteman in much larger scope of use apart from the testing area. The rule engine which forms the core of Byteman is able to inject bytecode into
almost every place in a call stack of a running java application. Thus the capability of bytecode injection enables manipulation of a java program without any limitations in the design of the language (e.g. access level modifiers).

Byteman offers a suite of built-in operations and conditions in order to support activities and tasks emphasized above. Built-in operations (such as delays, waits, countdowns, flag operations and signals) are mainly used for coordination of threads in multi-threaded applications where multiple threads run with no order and it is needed to control the flow of particular threads.

To simplify process of using Byteman in common usage or in the test automation, the Byteman rulecheck plugin and the BMUnit proje-cts were created in later releases of Byteman.

Byteman rulecheck plugin\footnote{\url{https://developer.jboss.org/wiki/CheckingYourBytemanRuleScriptsUnderMaven}} is a maven plugin which consists of a rule parser and a type checker. It runs the rule parser and type checker before every execution of any maven test to ensure that rules are still valid when a test code is modified.

BMUnit\footnote{\url{https://developer.jboss.org/wiki/BMUnitUsingBytemanWithJUnitOrTestNGFromMavenAndAnt}} is a java library which provides integration of Byteman with the two most used test frameworks, JUnit\footnote{\url{http://junit.org/}} and TestNG\footnote{\url{http://testng.org}}. BMUnit uses java annotations to load Byteman agent into JVM during tests, and to specify which rules should be installed by the agent before a test run (and uninstalled after test is completed).

Byteman is an \textit{Open Source} project and plays important role in \textit{JBoss Community}. It helps other JBoss projects with test automation and quality assurance.

\section{The Byteman Rule Language}
This section introduces fundamentals of the Byteman Rule Language, its syntax, semantics and functionality. The Byteman Rule Language is the only way how to inject bytecode into Java applications via Byteman. Understanding of the Byteman Rule Language is required in order to write Byteman rule scripts which forms the core functionality of this thesis. Following text is mainly focused on such parts of the Byteman Rule Language which are used in this work. Full description of the Byteman Rule Language is included in Byteman documentation \cite[The Byteman Rule Language]{byteman_doc}.

\subsection{Event Condition Action Rules}
\label{subsec:eca_sec}
Event Condition Action (ECA) languages are an intuitive and powerful paradigm for programming reactive systems \cite{eca}. The Byteman Rule Language is built on the Event Condition Action language and adopts its core features. Byteman employs ECA rule engine to inject bytecode at specified location during execution. The whole process of the bytecode injection is done by strict and unambiguous steps which arise from the ECA language.

A set of rules is defined in Byteman script which is a file with a \textit{.btm} suffix. Rules are used to determine how a specific part of an application should be transformed at runtime. A rule comprises three components, event, condition and action, which have following semantics\cite{eca}:

\begin{enumerate}
   \item when \textit{Event} occurs
   \item if \textit{Condition} is verified
   \item then execute \textit{Action}
\end{enumerate}

The ECA formalism provides a clear and easy-to-understand way how the bytecode injection should be performed without ambiguity.

Syntax of the rule consists of several parts which can be parsed by the rule engine. Following code snippet ilustrates rule scheme and its structure \cite[Rule Events]{byteman_doc}:

\begin{lstlisting}[caption = Byteman rule scheme, label = byteman_scheme]
# rule skeleton
RULE <rule name>
# comment line in rule body
CLASS <class name>
METHOD <method name>
BIND <bindings>
IF <condition>
DO <actions>
ENDRULE
\end{lstlisting}

Comments in Byteman script can be placed either between definitions of rules or within the rule body. Comment line begins with \textit{\#} symbol and must start and end with new line to be parsed correctly.

A rule starts with a name placed after the \textit{RULE} keyword. The name can have any form of a character sequence which length is at least one non-white space character. Rule names can be duplicated, however, it causes ambiguity in debugging rule scripts. The rule name is the only indetifier if an error occurs while parsing, type checking, compilation or execution of the rule.

\subsection{Rule events}
Byteman specifies a rule event as a \textit{location} in a target \textit{method} within a target \textit{class} \cite[Rule Events]{byteman_doc}. There are three types of target method: \textit{a static method}, \textit{an instance method} and \textit{a constructor}. Implicit location is \textit{AT ENTRY} if location was not specified.

Target class and target method are defined after the \textit{CLASS} and \textit{METHOD} keywords and must be in defined order on separate lines. The class name describes a class with or without the package specification. The method name can be defined either as a plain name or as a name with arguments and return type. The constructor method is defined by the special string \verb|<init>| in a method name.

Following code is an example of the rule event specification:

\begin{lstlisting}[caption = Rule event specification, label = rule_event_code]
#Log CMTTxInterceptor - invoke in our tx
RULE logCMTTxInterceptor.invokeInOurTx
CLASS org.jboss.as.ejb3.tx.CMTTxInterceptor
METHOD invokeInOurTx(InterceptorContext, TransactionManager, EJBComponent)
AT ENTRY
...
ENDRULE
\end{lstlisting}

    \appendix
    \chapter{First appendix}        % Appendices
    \Blindtext
    \chapter{Another appendix}
    \Blindtext

\bibliographystyle{IEEEtran}
\bibliography{sources}
\end{document}
