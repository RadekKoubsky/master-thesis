\documentclass[12pt,oneside]{fithesis2}
\usepackage[english]{babel}       % Multilingual support
\usepackage[utf8]{inputenc}       % UTF-8 encoding
\usepackage[T1]{fontenc}          % T1 font encoding
\usepackage[                      % A sans serif font that blends well with Palatino
  scaled=0.86
]{berasans}
\usepackage[                      % A tt font if you do not like LM's tt
  scaled=1.03
]{inconsolata}
\usepackage{blindtext}
\usepackage[hyphens]{url}
\usepackage[                      % Clickable links
  plainpages = false,               % We have multiple page numberings
  pdfpagelabels                     % Generate pdf page labels
]{hyperref}            % Lorem ipsum generator
\usepackage{listings}
\lstset{language=C, frame=lrtb, captionpos=b, breaklines=true, literate={\\\-}{}{0\discretionary{-}{}{}}}

\thesislang{en}                   % The language of the thesis
\thesistitle{Extend WildFly Application Server logging capabilities}       % The title of the thesis
\thesissubtitle{Diploma Thesis}  % The type of the thesis
\thesisstudent{Bc. Radek Koubsk√Ω}          % Your name
\thesiswoman{true}                % Your gender
\thesisfaculty{fi}                % Your faculty
\thesisyear{\the\year}     % The academic term of your thesis defense
\thesisadvisor{RNDr. Adam Rambousek, Ph.D.}   % Your advisor

\begin{document}
  \FrontMatter                    % The front matter
    \ThesisTitlePage                % The title page
    \begin{ThesisDeclaration}       % The declaration
      \DeclarationText
      \AdvisorName
    \end{ThesisDeclaration}
    \begin{ThesisThanks}            % The acknowledgements (optional)
      I would like to thank my supervisor\,\dots
    \end{ThesisThanks}
    \begin{ThesisAbstract}          % The abstract
      The aim of the bachelor work is to provide\,\dots
    \end{ThesisAbstract}
    \begin{ThesisKeyWords}          % The keywords
      keyword1, keyword2\,\dots
    \end{ThesisKeyWords}
    \tableofcontents                % The table of contents
%   \listoftables                   % The list of tables (optional)
%   \listoffigures                  % The list of figures (optional)
  
  \MainMatter                     % The main matter
    \chapter{Introduction}          % Chapters
\chapter{Byteman}
This chapter aims to introduce \textit{Byteman}, a bytecode manipulation tool, and its use in Java applications. Fundamental principles, functions and structure of Byteman will be described.
At the end of the chapter, an example of simple java application will be provided in order to understand bytecode injection which Byteman uses. More detailed documentation, tutorials and guidelines 
which cover almost every aspect of Byteman can be found in different versions at official website \url{http://byteman.jboss.org/}. Primary source for this thesis is Byteman documentation 3.0.0 \cite{byteman_doc}.

\section{Introduction to Byteman}
Byteman is a bytecode manipulation tool which uses a bytecode injection\footnote{Bytecode injection (or bytecode instrumentation) is a process of modifying the actual bytecode of a class} in order to change a java application as it is being loaded by \textit{Java virtual machine} or while the application is running \cite[Introduction to Byteman]{byteman_doc}.

Because of the bytecode injection, there is no need to change the original source code nor to recompile or redeploy the application itself. As it was mentioned, it is possible to add, replace or remove injected code at runtime while the application continues in execution. Byteman also provides a way to inject code into the Java language by modifying classes such as \textit{java.lang.Thread} and other classes from \textit{java.lang} package. Byteman uses simple scripting language called \textit{Event Condition Action} (\ref{subsec:eca_sec}) rules to determine how the original Java code should be transformed according to event and condition.

The original purpose of Byteman was to provide a mechanism for automation tests used in multi-threaded and multi-JVM Java applications using a technique called fault injection. Byteman can be used to inject faults which cause an application to invoke unusual or unexpected methods which are required for certain test scenarios. There are four areas supported by Byteman in automation testing \cite[Introduction to Byteman]{byteman_doc}:

\begin{itemize}
   \item tracing execution of specific code paths and displaying application or JVM state
   \item subverting normal execution by changing state, making unsche-duled method calls or forcing an unexpected return or throw
   \item orchestrating the timing of activities performed by independent application threads
   \item monitoring and gathering statistics summarising application a-nd JVM operation
\end{itemize}
However, the concept of bytecode injection involves Byteman in much larger scope of use apart from the testing area. The rule engine, which forms the core of Byteman, is able to inject bytecode into
almost every place in a call stack of a running java application. Thus the capability of bytecode injection enables manipulation of a Java program without any limitations in the design of the language (e.g. access level modifiers).

Byteman offers a suite of built-in operations and conditions in order to support activities and tasks emphasized above. Built-in operations (such as delays, waits, countdowns, flag operations and signals) are mainly used for coordination of threads in multi-threaded applications where multiple threads run with no order and it is needed to control the flow of particular threads.

To simplify process of using Byteman in common use or in the test automation, the Byteman rulecheck plugin and the BMUnit proje-cts were created in later releases of Byteman.

Byteman rulecheck plugin\footnote{\url{https://developer.jboss.org/wiki/CheckingYourBytemanRuleScriptsUnd-erMaven}} is a maven plugin which consists of a rule parser and a type checker. It runs the rule parser and type checker before every execution of any maven test to ensure that rules are still valid when a test code is modified.

BMUnit\footnote{\url{https://developer.jboss.org/wiki/BMUnitUsingBytemanWithJUnitOrTest-NGFromMavenAndAnt}} is a java library which provides integration of Byteman with the two most used test frameworks, JUnit\footnote{\url{http://junit.org/}} and TestNG\footnote{\url{http://testng.org}}. BMUnit uses java annotations to load Byteman agent into JVM during tests, and to specify which rules should be installed by the agent before a test run (and uninstalled after test is completed).

Byteman is an \textit{Open Source} project and plays important role in \textit{JBoss Community}. It helps other JBoss projects with test automation and quality assurance.

\section{The Byteman Rule Language}
This section introduces fundamentals of the Byteman Rule Language, its syntax, semantics and functionality. The Byteman Rule Language is the only way how to inject bytecode into Java applications via Byteman. Understanding of the Byteman Rule Language is required in order to write Byteman rule scripts which forms the core functionality of this thesis. The following text is mainly focused on such parts of the Byteman Rule Language which are used in this work. Full description of the Byteman Rule Language is included in Byteman documentation \cite[The Byteman Rule Language]{byteman_doc}.

\subsection{Event Condition Action Rules}
\label{subsec:eca_sec}
Event Condition Action (ECA) languages are an intuitive and powerful paradigm for programming reactive systems \cite{eca}. The Byteman Rule Language is built on the Event Condition Action language and adopts its core features. Byteman employs ECA rule engine to inject bytecode at specified location during execution. The whole process of the bytecode injection is done by strict and unambiguous steps which arise from the ECA language.

A set of rules is defined in Byteman script which is a file with a \textit{.btm} suffix. Rules are used to determine how a specific part of an application should be transformed at runtime. A rule comprises three components, event, condition and action, which have the following semantics\cite{eca}:

\begin{enumerate}
\label{itm:eca_if_then}
   \item when \textit{Event} occurs
   \item if \textit{Condition} is verified
   \item then execute \textit{Action}
\end{enumerate}

The ECA formalism provides a clear and easy-to-understand way how the bytecode injection should be performed without ambiguity.

Syntax of the rule consists of several parts which can be parsed by the rule engine. The following code snippet illustrates rule scheme and its structure \cite[Rule Events]{byteman_doc}:

\begin{lstlisting}[caption = Byteman rule scheme, label = byteman_scheme]
# rule skeleton
RULE <rule name>
# comment line in rule body
CLASS <class name>
METHOD <method name>
BIND <bindings>
IF <condition>
DO <actions>
ENDRULE
\end{lstlisting}

Comments in Byteman script can be placed either between definitions of rules or within the rule body. Comment line begins with \textit{\#} symbol and must start and end with new line to be parsed correctly.

A rule starts with a name placed after the \textit{RULE} keyword. The name can have any form of a character sequence which length is at least one non-white space character. Rule names can be duplicated, however, it causes ambiguity in debugging rule scripts. The rule name is the only identifier if an error occurs while parsing, type checking, compilation or execution of the rule.
provided with
\subsection{Rule events}
A rule event is an event related to an event part of the ECA language specification \ref{itm:eca_if_then}. Byteman specifies the rule event as a \textit{location} in a target \textit{method} within a target \textit{class} \cite[Rule Events]{byteman_doc}. There are three types of target method: \textit{a static method}, \textit{an instance method} and \textit{a constructor}. Implicit location is \textit{AT ENTRY} if location was not specified.

Target class and target method are defined after the \textit{CLASS} and \textit{METHOD} keywords and must be in defined order on separate lines. The class name describes a class with or without the package specification. The method name can be defined either as a plain name or as a name with arguments and return type. The constructor method is defined by the special string \verb|<init>| in the method name.

The following code is an example of the rule event specification:

\begin{lstlisting}[caption = Rule event specification, label = rule_event_code]
#Log CMTTxInterceptor - invoke in our tx
RULE logCMTTxInterceptor.invokeInOurTx
CLASS org.jboss.as.ejb3.tx.CMTTxInterceptor
METHOD invokeInOurTx(InterceptorContext, TransactionManager, EJBComponent)
AT ENTRY
...
ENDRULE
\end{lstlisting}

For the rule above, only one trigger point will by inserted into the class \textit{CMTTxInterceptor} from package \textit{org.jboss.as.ejb3.tx}. The triggermethod is the method with name \textit{invokeInOurTx} and list of three parameters: \textit{InterceptorContext}, \textit{TransactionManager} and \textit{EJBComponent}. Note that the package qualification of all method parameters is omitted. The type checker will look up the package of each parameter of the matched method. Same approach applies for the return type of the method. Inner classes can be located with \textit{\$} expression e.g.: \textit{my.package.OuterClass\$InnerClass}.

The rule event can employ any class of a Java application except the following classes:

\begin{itemize}
   \item classes in package \textit{java.lang}
   \item classes belonging to the Bytemam itself (\textit{org.jboss.byteman} package)
\end{itemize}

Injecting into Java classes is not allowed by default. Nevertheless, this option can be disabled by configuring the Java agent (here will be reference to Java agent section).

The example above uses the \textit{AT ENTRY} location specifier. Byteman includes rich set of location specifiers for the rule events. The following list of location specifiers is used in this work, for the full set of location specifiers, see section \cite[Location Specifiers]{byteman_doc}.

\begin{itemize}
\item	AT ENTRY
\item	AT EXIT
\item	AT LINE \textit{number}
\item	AFTER WRITE \textit{\$var-or-idx [count | ALL ]}
\item	AT INVOKE \textit{[ type .] method [ ( argtypes ) ] [count | ALL ]}
\item	AFTER INVOKE \textit{[ type .] method [ ( argtypes ) ][count | ALL ]}
\end{itemize}

Location specifier must be placed after the \textit{METHOD} specifier. If location specifier is omitted, the rule engine uses the \textit{AT ENTRY} location specifier.

An \textit{AT ENTRY} specifier defines a trigger point before the first bytecode instruction of a target method. If the target method is the constructor method, the trigger point is added immediately after the call to super constructor or to call to alternative constructor.

An \textit{AT EXIT} specifier defines a trigger point after the last bytecode instruction of the target method. The last bytecode instruction is a return statement which is responsible for exiting the target method in standard program flow. Standard program flow is the flow where no exception has occurred during method execution.

An \textit{AT LINE} specifier defines a trigger point before the first bytecode instruction which has source code line number greater than or equal to the line number argument provided in the specifier. The line number argument must be text which can be parsed to an integer number. If executable code does not exist at or after the line number, no trigger point will be inserted.

An \textit{AFTER WRITE} specifier starts with a \textit{\$} prefix and continues with local variable name, parameter name or parameter index of the target method. It locates a trigger point after the bytecode instruction which is responsible for the assignment of the named variable, parameter, or the parameter at specified index. The count argument defines the \textit{Nth} assignment to the variable, the default value is 1.

An \textit{AT INVOKE} specifier locates a trigger point before the first instruction which invokes a method provided as an argument of the specifier. Trigger point can be an invocation of a method or a constructor within the target method. The name of the invoked method can be described with or without package qualification. Method parameters are expressed as a list of parameters types separated by comma. Parameter type may contain package qualification or the package is inferred by the type checker.

An \textit{AFTER INVOKE} specifier locates a trigger point before the first instruction which follows an invocation of a method provided as an argument of the specifier. Method description follows same rules as in the \textit{AT INVOKE} specifier.

\subsection{Rule Bindings}
The rule binding specification is used for binding values to variables in a context of a rule. It is possible to assign a value to a new variable or reassign an existing variable. The context of the rule provides access to methods and variables of target class instance (if the target method is not static) and local variables in the scope of the trigger method. The assignments are performed each time the rule is triggered \cite[Rule Bindings]{byteman_doc}. The following example shows simple binding in the rule body: 

\begin{lstlisting}[caption = Rule binding specification, label = rule_binding_code]
RULE logChainInitiationObserver.onMessage
CLASS org.apache.cxf.transport.ChainInitiationObserver
METHOD onMessage(Message)
AT ENTRY
BIND bindMessage:Message = $1;
IF bindMessage != null
DO ...
ENDRULE
\end{lstlisting}

Binding defined in the rule above starts with the \textit{BIND} keyword which is followed with the variable \textit{bindMessage} on the left side, and the value on the right side. The assigned value is the value of the target method parameter at index 1. The type \textit{Message} of the \textit{bindMessage} variable is defined between the ":" character and "=" operator. If the type specification of the variable is omitted, it will be inferred from the type of the \textit{\$1} value. If there is more than one binding, each binding is ended with semicolon.

\subsection{Rule Expressions}
\label{subsec:rule_exp}
Rule expressions can be used in the rule body and provide several operations such as method invocations, built-in calls and field references. Byteman defines the following set of expressions \cite[Rule Expressions]{byteman_doc}:

\begin{itemize}
	\item references to previously bound variables
	\item references to the trigger method recipient or parameters
	\item references to the local variables in scope at the trigger point
	\item references to special variables:
\begin{lstlisting}[frame=]
$!, $^, $#, $*, $@, $CLASS and $METHOD
\end{lstlisting}
	\item static field references
	\item primitive literals
	\item field accesses
	\item static or instance method invocations
	\item built-in operation invocations
\end{itemize}

It is possible to combine simple expressions to construct complex expressions using standard Java operators:
\begin{lstlisting}[frame=]
+, -, *, /, %, &, |, ^, &&, ||, !, =, ==, !=, <. <=, >, >=, new, etc.
\end{lstlisting}

A reference to a trigger method instance is provided with \textit{\$0} symbol. If the trigger method is a static method, the \textit{\$0} expression is invalid. A reference to the trigger method parameters is provided with \textit{\$} symbol and index (1, 2, 3...). Index specifies position of a parameter in the trigger method.

A \textit{\$CLASS} special variable provides a \textit{String} representation of the full package qualified class whose method is the target of a rule. In most cases, the variable has the same value as the target class after the \textit{CLASS} keyword. However, if the target class is an interface, the value of the \textit{\$CLASS} variable can vary depending on interface implementation.

A \textit{\$METHOD} special variable provides a \textit{String} representation of the full name of the target method of a rule. Note that the method name is same as the target method specified after the \textit{METHOD} event specifier. The printed name of the method consists of full package qualified return type, bare method name and full package qualified list of parameters types.

A \textit{\$@} expression can be used only with \textit{AT INVOKE} location specifier. The value of the expression refers to an \textit{Object[]} array. The first slot in the array is an instance of a class whose method is specified in \textit{AT INVOKE} (if the target method is static, the value is null). Values in slots at indexes 1, 2, 3... are values of the target method parameters.

The following rule shows use of the expressions mentioned above:
\begin{lstlisting}[caption = Rule Expressions, label = rule_expressions_code]
RULE logPutData
CLASS org.jboss.as.webservices.deployers.WSComponentInstanceAssociationInterceptor
METHOD processInvocation(InterceptorContext)
AT INVOKE putPrivateData(Class, Object)
IF true
DO log($CLASS, "DEBUG", "Putting component instance to interceptor context:" +
"\nClass: " + $@[1] + "\nInstance: " + $@[2]);
ENDRULE
\end{lstlisting}

\subsection{Rule actions}
Rule actions can be represented by rule expressions \ref{subsec:rule_exp} or return or throw actions. A rule expression which is used in action may have any type including void type \cite[Rule actions]{byteman_doc}.

A rule expression can employ standard built-in methods (link) or methods defined in additional helper class (link) bound to a rule.

A return action starts with the \textit{return} keyword and can return a plain constant or a complex rule expression which is evaluated to a return value. Type of the constant or the complex expression must be assignable to the return type of the trigger method. If the type of the trigger method is void, the return value in of the return action can be omitted \cite[Rule actions]{byteman_doc}..

A throw action consists of the \textit{throw} keyword and an expression which is a constructor of a \textit{throwable} to be thrown in a trigger method. The type of the \textit{throwable} can be class \textit{java.lang.RuntimeException}, \textit{java.lang.Error} or its subclasses.

    \appendix
    \chapter{First appendix}        % Appendices
    \Blindtext
    \chapter{Another appendix}
    \Blindtext

\bibliographystyle{IEEEtran}
\bibliography{sources}
\end{document}
